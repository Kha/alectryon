<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Multi-prover documents</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0, Lean3 vLean (version 4.0.0-nightly-2022-01-07, commit bef161caf75a, Release). Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.<br>Hover-Settings: Show types:<input id="toggleswitch" type="checkbox" onClick="toggleShowTypes(this);"> Show goals:<input id="toggleswitch" type="checkbox" onClick="toggleShowGoals(this);" checked><br></div><div class="document" id="multi-prover-documents">
<h1 class="title">Multi-prover documents</h1>

<p>Alectryon documents can use multiple provers.  Inputs for each prover are processed independently.</p>
<p>To compile:</p>
<pre class="literal-block">
alectryon polyglot.rst
    # reST+‚Ä¶ ‚Üí HTML;  produces ‚Äòpolyglot.html‚Äô
</pre>
<pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><div class="alectryon-token"><span class="kn">Require Import</span> Arith.</div></span></span><span class="alectryon-wsp"><div class="alectryon-token">

</div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="polyglot-rst-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="polyglot-rst-chk0"><div class="alectryon-token"><span class="kn">Lemma</span> <span class="nf">mul_comm</span> :
  <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>: nat, a * b = b * a.</div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : nat, a * b = b * a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token">
</div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="polyglot-rst-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="polyglot-rst-chk1"><div class="alectryon-token"><span class="kn">Proof</span>.</div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : nat, a * b = b * a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token">
  </div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="polyglot-rst-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="polyglot-rst-chk2"><div class="alectryon-token"><span class="nb">induction</span> a; <span class="nb">simpl</span>.</div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : nat, <span class="mi">0</span> = b * <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="polyglot-rst-chk3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : nat, a * b = b * a</span></span></span><br></div><label class="goal-separator" for="polyglot-rst-chk3"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : nat, b + a * b = b * S a</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token">
  </div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="polyglot-rst-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="polyglot-rst-chk4"><div class="alectryon-token">-</div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : nat, <span class="mi">0</span> = b * <span class="mi">0</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token"> </div></span><span class="alectryon-sentence"><span class="alectryon-input"><div class="alectryon-token"><span class="nb">induction</span> b; <span class="nb">simpl</span>; <span class="bp">congruence</span>.</div></span></span><span class="alectryon-wsp"><div class="alectryon-token">
  </div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="polyglot-rst-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="polyglot-rst-chk5"><div class="alectryon-token">-</div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : nat, a * b = b * a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> : nat, b + a * b = b * S a</div></blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token"> </div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="polyglot-rst-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="polyglot-rst-chk6"><div class="alectryon-token"><span class="nb">induction</span> b; <span class="nb">simpl</span>.</div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : nat, a * b = b * a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * <span class="mi">0</span> = <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="polyglot-rst-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : nat, a * b = b * a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>b + a * b = b * S a</span></span></span><br></div><label class="goal-separator" for="polyglot-rst-chk7"><hr></label><div class="goal-conclusion">S (b + a * S b) = S (a + b * S a)</div></blockquote></div></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token">
    </div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="polyglot-rst-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="polyglot-rst-chk8"><div class="alectryon-token">+</div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : nat, a * b = b * a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a * <span class="mi">0</span> = <span class="mi">0</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token"> </div></span><span class="alectryon-sentence"><span class="alectryon-input"><div class="alectryon-token"><span class="nb">rewrite</span> IHa; <span class="bp">reflexivity</span>.</div></span></span><span class="alectryon-wsp"><div class="alectryon-token">
    </div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="polyglot-rst-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="polyglot-rst-chk9"><div class="alectryon-token">+</div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : nat, a * b = b * a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>b + a * b = b * S a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (b + a * S b) = S (a + b * S a)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token"> </div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="polyglot-rst-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="polyglot-rst-chka"><div class="alectryon-token"><span class="nb">rewrite</span> &lt;- IHb, IHa.</div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : nat, a * b = b * a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>b + a * b = b * S a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (b + S b * a) = S (a + (b + a * b))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token">
      </div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="polyglot-rst-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="polyglot-rst-chkb"><div class="alectryon-token"><span class="nb">simpl</span>.</div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : nat, a * b = b * a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>b + a * b = b * S a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (b + (a + b * a)) = S (a + (b + a * b))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token"> </div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="polyglot-rst-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="polyglot-rst-chkc"><div class="alectryon-token"><span class="nb">rewrite</span> IHa.</div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : nat, a * b = b * a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>b + a * b = b * S a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (b + (a + b * a)) = S (a + (b + b * a))</div></blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token">
      </div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="polyglot-rst-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="polyglot-rst-chkd"><div class="alectryon-token"><span class="nb">rewrite</span> !Nat.add_assoc.</div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : nat, a * b = b * a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>b + a * b = b * S a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (b + a + b * a) = S (a + b + b * a)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token">
      </div></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="polyglot-rst-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="polyglot-rst-chke"><div class="alectryon-token"><span class="nb">rewrite</span> (Nat.add_comm b a).</div></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : nat, a * b = b * a</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHb</var><span class="hyp-type"><b>: </b><span>b + a * b = b * S a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">S (a + b + b * a) = S (a + b + b * a)</div></blockquote></div></div></small></span><span class="alectryon-wsp"><div class="alectryon-token">
      </div></span><span class="alectryon-sentence"><span class="alectryon-input"><div class="alectryon-token"><span class="bp">reflexivity</span>.</div></span></span><span class="alectryon-wsp"><div class="alectryon-token">
</div></span><span class="alectryon-sentence"><span class="alectryon-input"><div class="alectryon-token"><span class="kn">Qed</span>.</div></span></span></pre><pre class="alectryon-io type-info-hidden highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><div class="alectryon-token"><span class="kn">open</span> nat

<span class="kd">def</span> Sum : nat <span class="bp">‚Üí</span> nat
<span class="bp">|</span> <span class="mi">0</span>        := <span class="mi">0</span>
<span class="bp">|</span> (succ n) := (succ n) <span class="bp">+</span> Sum n

<span class="k">#eval</span> (Sum <span class="mi">10</span>)

<span class="kn">namespace</span> nat
  <span class="kd">lemma</span> mul_two: <span class="k">forall</span> n: nat, <span class="mi">2</span> <span class="bp">*</span> n <span class="bp">=</span> n <span class="bp">+</span> n :=
  <span class="kd">begin</span>
    intros n, induction n,
    { refl },
    { rw [<span class="bp">‚Üê</span> nat.add_one, nat.left_distrib, n_ih],
      change (<span class="mi">2</span> <span class="bp">*</span> <span class="mi">1</span>) <span class="k">with</span> (<span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span>),
      simp [nat.add_assoc, nat.add_comm <span class="mi">1</span>], }
  <span class="kd">end</span>
<span class="kd">end</span> nat

<span class="kd">lemma</span> gauss: <span class="k">forall</span> n: nat, <span class="mi">2</span> <span class="bp">*</span> Sum n <span class="bp">=</span> n <span class="bp">*</span> (n <span class="bp">+</span> <span class="mi">1</span>) :=
<span class="kd">begin</span>
  intros n,
  induction n <span class="k">with</span> n ih<span class="bp">;</span> simp [Sum],
  { refl },
  { simp [nat.left_distrib],
    rw [ih, <span class="bp">‚Üê</span> nat.add_one],
    simp [nat.left_distrib, nat.right_distrib,
          nat.mul_one, nat.one_mul, nat.mul_two]<span class="bp">;</span>
      change (<span class="mi">1</span> <span class="bp">*</span> <span class="mi">1</span>) <span class="k">with</span> <span class="mi">1</span><span class="bp">;</span> change (<span class="mi">2</span> <span class="bp">*</span> <span class="mi">1</span>) <span class="k">with</span> (<span class="mi">1</span> <span class="bp">+</span> <span class="mi">1</span>)<span class="bp">;</span>
      rw [nat.add_comm]<span class="bp">;</span> simp [nat.add_assoc] },
<span class="kd">end</span></div></span></span></pre><div class="system-messages section">
<h1>Docutils System Messages</h1>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">polyglot.rst</tt>)</p>
Lean raised an exception:
Driver Lean3 (lean) exited with code 1:
   Miscellaneous:
     --help -h          display this message
     --version -v       display version number
     --githash          display the git commit hash number used to build this binary
     --run              call the 'main' definition in a file with the remaining arguments
     --o=oname -o       create olean file
     --c=fname -c       name of the C output file
     --stdin            take input from stdin
     --root=dir         set package root directory from which the module name of the input file is calculated
                        (default: current working directory)
     --trust=num -t     trust level (default: max) 0 means do not trust any macro,
                        and type check all imported modules
     --quiet -q         do not print verbose messages
     --memory=num -M    maximum amount of memory that should be used by Lean
                        (in megabytes)
     --timeout=num -T   maximum number of memory allocations per task
                        this is a deterministic way of interrupting long running tasks
     --threads=num -j   number of threads used to process lean files
     --tstack=num -s    thread stack size in Kb
     --server           start lean in server mode
     --worker           start lean in server-worker mode
     --plugin=file      load and initialize Lean shared library for registering linters etc.
     --load-dynlib=file load shared library to make its symbols available to the interpreter
     --deps             just print dependencies of a Lean input
     --print-prefix     print the installation prefix for Lean and exit
     --print-libdir     print the installation directory for Lean's built-in libraries and exit
     --profile          display elaboration/type checking time for each definition/theorem
     --stats            display environment statistics
     -D name=value      set a configuration option (see set_option command)

   lean: unrecognized option `--ast'
   Unknown command line option
   Lean (version 4.0.0-nightly-2022-01-07, commit bef161caf75a, Release)
</div>
</div>
</div>
</div></body>
</html>
